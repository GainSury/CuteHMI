# CuteHMI - Skeleton

This is a sample extension skeleton generated by `ExtensionSkeleton.qbs`. It can be used as a base for implementing custom
extensions.

## Directories

Directory structure of extensions follows standard QML extensions scheme. Directory name of the extension defines fully qualified
extension __name__ denoted as __VendorName.ExtensionName.MajorVersion__. Therefore this extension is named `CuteHMI.Skeleton.0`.

Fully qualified __name__ consists of __base name__ (`CuteHMI.Skeleton`) and __major version suffix__ (`.0`). __Base name__ consists
of two parts: __vendor name__ (`CuteHMI`) and __extension name__ (`Skeleton`). It is allowed to omit __extension name__ for a single
extension from a specific vendor.

Extension directories follow camel-case (PascalCase) rules in order to remain consistent with QML extension naming convention used
by Qt. On the other hand following this convention within C++ would be inconvenient in many places, so compromises have been made.
Sometimes semantic members of extension directory name are lowercased. To express such intention, a pattern
__VendorName.ExtensionName.MajorVersion__ will be transformed according to the intention (i.e. __vendor name__ represents lowercased
__VendorName__).

Typically each extension will have directory structure similar to this one.

- `include` - public header files (available to other modules).
    - __vendor name__ - `cutehmi` should be renamed to match vendor name.
        - __extension name__ - `skeleton` should be renamed to match extension name.
            - `internal` - some headers need to be publicly available, but they are implementation detail. This directory is for
            such files.
- `src` - private header files and implementation.
    - __vendor name__ - `cutehmi` should be renamed to match vendor name.
        - __extension name__ - `skeleton` should be renamed to match extension name.
            - `internal` - corresponds with `internal` subdirectory inside `include` directory.
- `tests` - Tests.
- `doc` - Documentation related files.
- `dev` - Development notes.

To keep things in order and avoid naming conflicts, C++ namespaces should reflect above directory structure within `include` and
`src` directories.

## Creating custom extension

One way to boost the process of creating an extension is to copy the contents of CuteHMI.Skeleton and modify them.

Less tedious way of doing this is to use `ExtensionSkeleton.qbs` to generate the files. The process can be reduced to following
tasks.
- Create an extension directory.
- Copy `Skeleton.0.qbs` to the extension directory, rename it to match extension name. Modify its contents.
- Tell Qbs to build `ExtensionSkeleton.qbs`.
    - In a console, `cd` to `CuteHMI` top level directory.
    - Create temporary build directory outside of the top level CuteHMI directory: `mkdir ../build-temp` and `cd` into it.
    - Execute Qbs: `qbs build -f ../CuteHMI/ExtensionSkeleton.qbs --no-install -p ExtensionSkeleton products.CuteHMI.2.type:[] products.ExtensionSkeleton.extension:VendorName.ExtensionName.0  products.VendorName.ExtensionName.0.type:[]`
    Replace `VendorName` and `ExtensionName` to match names of the extension.
    - Delete temporary build directory.

If you haven't used Qbs from command line you may need to configure toolchains, Qt versions, specify Qbs profile or set up default
profile. Refer to [Qbs documentation](https://doc.qt.io/qbs/qt-versions.html) on how to do this.

Project `ExtensionSkeleton.qbs` can be also opened from QtCreator. You can simply locate the string
`property string extension: "CuteHMI.Skeleton.0"` and temporarily modify it to match your extenions. This is probably least
intrusive, but most straightforward way to generate skeleton for an extension. QtCreator also allows you to modify this property
through `Properties:` box in the `Projects` mode.

## Providing extensiton with a code

Next steps depend on what your extension is going to accomplish. CuteHMI extensions combine the functionality of libraries and QML
extensions. Extension can be a pure QML runtime extension, a pure binary library, or it can be a mix of both.

If you would like to provide a QML extension, then you should refer to documentatino on
[qmldir](https://doc.qt.io/qt-5/qtqml-modules-qmldir.html) files. You have to create `qmldir` file, but `qmltypes` file will be
generated automatically for each extension thanks to `cutehmi.qmltypes` Qbs module dependecy, which is set for each
cutehmi.Extension item by default.

To make an extension that acts as a QML extension, but uses C++ code, you may refer to
[Creating C++ Plugins for QML](https://doc.qt.io/qt-5/qtqml-modules-cppplugins.html). You can ignore the creation of `.pro` files
and simply add files to Qbs project. Key concepts to focus on is a class that extends `QQmlExtensionPlugin`, `qmlRegisterType`
function template that exposes QObject derived and entries in `qmldir` file. You may also check out the tutorial
[https://doc.qt.io/qt-5/qtqml-tutorials-extending-qml-example.html](Writing QML Extensions with C++).

To create an extension that behaves like a library (i.e. other extensions can be linked with it) you should refer to Qt
documentation on [Creating Shared Libraries](https://doc.qt.io/qt-5/sharedlibrary.html). Note that mentioned `MYSHAREDLIB_EXPORT`
macros are defined within `platform.hpp` according to a pattern `VENDORNAME_EXTENSIONNAME_API`. Again, you don't need to worry about
`.pro` files.
