# Templates - Skeleton

This is a sample extension skeleton generated by `ExtensionSkeleton.qbs`. It can be used as a base for implementing custom
extensions.

One way to boost the process of creating an extension is to copy the contents of Templates.Skeleton and modify them. For the
extensions that are not using any C++ code you only need to copy `Skeleton.0.qbs` to custom extension directory, rename it
accordingly, edit its properties and provide a `qmldir` file. You should also provide your own `README.md` and `LICENSE` files. To
create an extensions, which uses C++ code you would probably need to modify each C++ file.

Less tedious way of doing this is to use `ExtensionSkeleton.qbs` to generate the files. The process can be reduced to following
tasks.

- Create an extension directory.
- Copy `Skeleton.0.qbs` to the extension directory, rename it to match extension name. Modify its contents.
- Tell Qbs to build `ExtensionSkeleton.qbs`.
    - In a console, `cd` to `CuteHMI` top level directory.
    - Create temporary build directory outside of the top level CuteHMI directory: `mkdir ../build-temp` and `cd` into it.
    - Execute Qbs: `qbs build -f ../cutehmi/ExtensionSkeleton.qbs --no-install -p ExtensionSkeleton products.CuteHMI.2.type:'[]' products.ExtensionSkeleton.extension:<VendorName>.<ExtensionName>.<0>  products.<VendorName>.<ExtensionName>.0.type:'[]'`
      Replace `<VendorName>` and `<ExtensionName>` to match names of the extension.
    - Delete temporary build directory.

If you haven't used Qbs from command line you may need to configure toolchains, Qt versions, specify Qbs profile or set up default
profile. Refer to [Qbs documentation](https://doc.qt.io/qbs/qt-versions.html) on how to do this.

Project `ExtensionSkeleton.qbs` can be also opened from QtCreator. You can simply locate the string
`property string extension: "Templates.Skeleton.0"` and temporarily modify it to match your extenions. This is probably least
intrusive, but most straightforward way to generate skeleton for an extension. QtCreator also allows you to modify this property
through `Properties:` box in the `Projects` mode.


## Providing extension skeleton with a code

Next steps depend on what your extension is going to accomplish. CuteHMI
extensions combine the functionality of libraries and QML extensions. Extension
can be a pure QML runtime extension, a pure binary library, or it can be a mix
of both.

If you would like to provide a QML extension, then you should refer to
documentation on [qmldir](https://doc.qt.io/qt-5/qtqml-modules-qmldir.html)
files. You have to create `qmldir` file. You can use `cutehmi.qmltypes` Qbs
module dependency to generate `plugins.qmltypes` file.

To make an extension that acts as a QML extension, but uses C++ code, you may
refer to [Creating C++ Plugins for QML](https://doc.qt.io/qt-5/qtqml-modules-cppplugins.html).
You can ignore the creation of `.pro` files and simply add files to Qbs project.
Key concepts to focus on is a class that extends `QQmlExtensionPlugin`,
`qmlRegisterType` function template that exposes `QObject` derived classes and
entries in `qmldir` file. You may also check out the tutorial
[Writing QML Extensions with C++](https://doc.qt.io/qt-5/qtqml-tutorials-extending-qml-example.html).

To create an extension that behaves like a library (i.e. other extensions can be
linked with it) you should refer to Qt documentation on
[Creating Shared Libraries](https://doc.qt.io/qt-5/sharedlibrary.html).
Note that mentioned `MYSHAREDLIB_EXPORT` macros are defined within
`platform.hpp` according to a pattern `VENDORNAME_EXTENSIONNAME_API`. Again,
you don't need to worry about `.pro` files.
