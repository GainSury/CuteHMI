import qbs
import qbs.File
import qbs.FileInfo
import qbs.TextFile

Project {
	SubProject {
		filePath: "CuteHMI.qbs"

		Properties {
			buildExamples: false
		}
	}

	Product {
		name: "ExtensionSkeleton"

		type: ["skeleton"]

		property string extension: "CuteHMI.Skeleton.0"

		property bool generatePlatform: true

		property bool generateCommon: true

		property bool generateMetadata: true

		property bool generateLogging: true

		property bool generateLoggingTest: generateLogging

		property bool generateTestsQbs: generateLoggingTest

		Depends { name: extension }

		Depends { name: "CuteHMI.2"; required: false }

		Depends { name: "cutehmi.metadata"; required: false }

		Rule {
			inputs: ["qbs"]
			inputsFromDependencies: "qbs"
			multiplex: true

			prepare: {
				console.info("Preparing skeletal artifacts for product '" + product.extension + "'")

				var metadataAvailable = false
				var cutehmiAvailable = false
				var qtCoreAvailable = false
				var extensionProduct
				for (i in product.dependencies) {
					if (product.dependencies[i].name === product.extension)
						extensionProduct = product.dependencies[i]
				}
				for (i in extensionProduct.dependencies) {
					if (extensionProduct.dependencies[i].name === "Qt.core")
						qtCoreAvailable = true
					if (extensionProduct.dependencies[i].name === "CuteHMI.2")
						cutehmiAvailable = true
					if (extensionProduct.dependencies[i].name === "cutehmi.metadata")
						metadataAvailable = true
				}

				if (!qtCoreAvailable) {
					console.warn("Extension must depend on 'Qt.core' module, please add appropriate Depends item")
					product.generateLogging = false
					product.generatePlatform = false
				}
				if (!cutehmiAvailable) {
					console.warn("Extension 'CuteHMI.2' not specified within Depends item - this may disable generation of certain artifacts")
					product.generateLogging = false
				}
				if (!metadataAvailable) {
					console.warn("Qbs module 'cutehmi.metadata' not specified within Depends item - this may disable generation of certain artifacts")
					product.generateMetadata = false
				}

				if (!File.exists(extensionProduct.sourceDirectory + "/README.md"))
					console.warn("File 'README.md' does not exist in '" + extensionProduct.sourceDirectory + "' directory, please create it (file should contain a description of extension)")
				if (!File.exists(extensionProduct.sourceDirectory + "/LICENSE"))
					console.warn("File 'LICENSE' does not exist in '" + extensionProduct.sourceDirectory + "' directory, please create it (file should contain a text of a license under which extension is distributed)")

				var autogeneratedNotice = "This file has been autogenerated by 'ExtensionSkeleton.qbs'."
				var macroPrefix = extensionProduct.baseName.toUpperCase().replace(/\./g, '_')
				var loggingCategory = extensionProduct.name.toLowerCase().replace(/\./g, '_')
				var namespace = extensionProduct.baseName.toLowerCase().replace(/\./g, '::')
				var namespaceArr = extensionProduct.baseName.toLowerCase().split('.');

				var includeDirCmd = new JavaScriptCommand();
				includeDirCmd.description = "creating " + outputs.includeDir[0].filePath
				includeDirCmd.highlight = "filegen";
				includeDirCmd.sourceCode = function() {
					File.makePath(outputs.includeDir[0].filePath)
				}

				var internalIncludeDirCmd = new JavaScriptCommand();
				internalIncludeDirCmd.description = "creating " + outputs.internalIncludeDir[0].filePath
				internalIncludeDirCmd.highlight = "filegen";
				internalIncludeDirCmd.sourceCode = function() {
					File.makePath(outputs.internalIncludeDir[0].filePath)
				}

				var testsDirCmd = new JavaScriptCommand();
				testsDirCmd.description = "creating " + outputs.testsDir[0].filePath
				testsDirCmd.highlight = "filegen";
				testsDirCmd.sourceCode = function() {
					File.makePath(outputs.testsDir[0].filePath)
				}

				var platformHppCmd = new JavaScriptCommand();
				platformHppCmd.description = "generating " + outputs.platformHpp[0].filePath
				platformHppCmd.highlight = "codegen";
				platformHppCmd.includeGuard = "H_" + FileInfo.relativePath(product.sourceDirectory, outputs.platformHpp[0].filePath).toUpperCase().replace(/[\.\/]/g, '_')
				platformHppCmd.autogeneratedNotice = autogeneratedNotice
				platformHppCmd.macroPrefix = macroPrefix
				platformHppCmd.sourceCode = function() {
					var f = new TextFile(outputs.platformHpp[0].filePath, TextFile.WriteOnly);
					try {
						f.writeLine("#ifndef " + includeGuard)
						f.writeLine("#define " + includeGuard)

						f.writeLine("")
						f.writeLine("// " + autogeneratedNotice)

						f.writeLine("")
						f.writeLine("#include <QtGlobal>")

						f.writeLine("")
						f.writeLine("#ifdef " + macroPrefix + "_DYNAMIC")
						f.writeLine("	#ifdef " + macroPrefix + "_BUILD")
						f.writeLine("		// Export symbols to dynamic library.")
						f.writeLine("		#define " + macroPrefix + "_API Q_DECL_EXPORT")
						f.writeLine("		#ifdef " + macroPrefix + "_TEST")
						f.writeLine("			// Export symbols to dynamic library.")
						f.writeLine("			#define " + macroPrefix + "_PRIVATE Q_DECL_EXPORT")
						f.writeLine("		#else")
						f.writeLine("			#define " + macroPrefix + "_PRIVATE")
						f.writeLine("		#endif")
						f.writeLine("	#else")
						f.writeLine("		// Using symbols from dynamic library.")
						f.writeLine("		#define " + macroPrefix + "_API Q_DECL_IMPORT")
						f.writeLine("		#ifdef " + macroPrefix + "_TEST")
						f.writeLine("			// Using symbols from dynamic library.")
						f.writeLine("			#define " + macroPrefix + "_PRIVATE Q_DECL_IMPORT")
						f.writeLine("		#else")
						f.writeLine("			#define " + macroPrefix + "_PRIVATE")
						f.writeLine("		#endif")
						f.writeLine("	#endif")
						f.writeLine("#else")
						f.writeLine("	#define " + macroPrefix + "_API")
						f.writeLine("#endif")

						f.writeLine("")
						f.writeLine("#endif")
					} finally {
						f.close()
					}
				}

				var commonHppCmd = new JavaScriptCommand();
				commonHppCmd.description = "generating " + outputs.commonHpp[0].filePath
				commonHppCmd.highlight = "codegen";
				commonHppCmd.includeGuard = "H_" + FileInfo.relativePath(product.sourceDirectory, outputs.commonHpp[0].filePath).toUpperCase().replace(/[\.\/]/g, '_')
				commonHppCmd.autogeneratedNotice = autogeneratedNotice
				commonHppCmd.usePlatform = product.generatePlatform
				commonHppCmd.useMetadata = product.generateMetadata
				commonHppCmd.useLogging = product.generateLogging
				commonHppCmd.useCutehmi = cutehmiAvailable
				commonHppCmd.sourceCode = function() {
					var f = new TextFile(outputs.commonHpp[0].filePath, TextFile.WriteOnly);
					try {
						f.writeLine("#ifndef " + includeGuard)
						f.writeLine("#define " + includeGuard)

						f.writeLine("")
						f.writeLine("// " + autogeneratedNotice)

						f.writeLine("")
						if (usePlatform)
							f.writeLine("#include \"platform.hpp\"")
						if (useMetadata)
							f.writeLine("#include \"../metadata.hpp\"")
						if (useLogging)
							f.writeLine("#include \"../logging.hpp\"")

						f.writeLine("")
						if (useCutehmi)
							f.writeLine("#include <cutehmi/MPtr.hpp>")

						f.writeLine("")
						f.writeLine("#include <QtGlobal>")

						f.writeLine("")
						f.writeLine("#endif")
					} finally {
						f.close()
					}
				}

				var metadataHppCmd = new JavaScriptCommand();
				metadataHppCmd.description = "generating " + outputs.metadataHpp[0].filePath
				metadataHppCmd.highlight = "codegen";
				metadataHppCmd.includeGuard = "H_" + FileInfo.relativePath(product.sourceDirectory, outputs.metadataHpp[0].filePath).toUpperCase().replace(/[\.\/]/g, '_')
				metadataHppCmd.autogeneratedNotice = autogeneratedNotice
				metadataHppCmd.metadataHppPathPrefix = FileInfo.relativePath(FileInfo.path(outputs.metadataHpp[0].filePath), extensionProduct.sourceDirectory)
				metadataHppCmd.sourceCode = function() {
					var f = new TextFile(outputs.metadataHpp[0].filePath, TextFile.WriteOnly);
					try {
						f.writeLine("#ifndef " + includeGuard)
						f.writeLine("#define " + includeGuard)

						f.writeLine("")
						f.writeLine("// " + autogeneratedNotice)

						f.writeLine("")
						f.writeLine("#include \"" + metadataHppPathPrefix + "cutehmi.metadata.hpp\"")

						f.writeLine("")
						f.writeLine("#endif")
					} finally {
						f.close()
					}
				}

				var loggingHppCmd = new JavaScriptCommand();
				loggingHppCmd.description = "generating " + outputs.loggingHpp[0].filePath
				loggingHppCmd.highlight = "codegen";
				loggingHppCmd.includeGuard = "H_" + FileInfo.relativePath(product.sourceDirectory, outputs.loggingHpp[0].filePath).toUpperCase().replace(/[\.\/]/g, '_')
				loggingHppCmd.autogeneratedNotice = autogeneratedNotice
				loggingHppCmd.macroPrefix = macroPrefix
				loggingHppCmd.namespaceArr = namespaceArr
				loggingHppCmd.loggingCategory = loggingCategory
				loggingHppCmd.sourceCode = function() {
					var f = new TextFile(outputs.loggingHpp[0].filePath, TextFile.WriteOnly);
					try {
						f.writeLine("#ifndef " + includeGuard)
						f.writeLine("#define " + includeGuard)

						f.writeLine("")
						f.writeLine("// " + autogeneratedNotice)

						f.writeLine("")
						f.writeLine("#include \"internal/platform.hpp\"")
						f.writeLine("#include <cutehmi/loggingMacros.hpp>")

						f.writeLine("")
						f.writeLine(macroPrefix + "_API Q_DECLARE_LOGGING_CATEGORY(" + loggingCategory + "_loggingCategory)")

						f.writeLine("")
						for (var level in namespaceArr)
							f.writeLine("namespace " + namespaceArr[level] + " {")

						f.writeLine("")
						f.writeLine("inline")
						f.writeLine("const QLoggingCategory & loggingCategory()")
						f.writeLine("{")
						f.writeLine("	return " + loggingCategory + "_loggingCategory();")
						f.writeLine("}")

						f.writeLine("")
						for (var level in namespaceArr)
							f.writeLine("}")

						f.writeLine("")
						f.writeLine("#endif")
					} finally {
						f.close()
					}
				}


				var loggingCppCmd = new JavaScriptCommand();
				loggingCppCmd.description = "generating " + outputs.loggingCpp[0].filePath
				loggingCppCmd.highlight = "codegen";
				loggingCppCmd.autogeneratedNotice = autogeneratedNotice
				loggingCppCmd.loggingCategory = loggingCategory
				loggingCppCmd.loggingCategoryId = extensionProduct.name
				loggingCppCmd.macroPrefix = macroPrefix
				loggingCppCmd.useMetadata = product.generateMetadata
				loggingCppCmd.includeDirPrefix = FileInfo.relativePath(extensionProduct.sourceDirectory + "/include", outputs.includeDir[0].filePath)
				loggingCppCmd.sourceCode = function() {
					var f = new TextFile(outputs.loggingCpp[0].filePath, TextFile.WriteOnly);
					try {
						f.writeLine("#include <" + includeDirPrefix + "/logging.hpp>")
						if (useMetadata)
							f.writeLine("#include <" + includeDirPrefix + "/metadata.hpp>")

						f.writeLine("")
						f.writeLine("// " + autogeneratedNotice)

						f.writeLine("")
						if (useMetadata)
							f.writeLine("Q_LOGGING_CATEGORY(" + loggingCategory + "_loggingCategory, " + macroPrefix + "_NAME)")
						else
							f.writeLine("Q_LOGGING_CATEGORY(" + loggingCategory + "_loggingCategory, \"" + loggingCategoryId + "\")")
					} finally {
						f.close()
					}
				}

				var loggingTestCmd = new JavaScriptCommand();
				loggingTestCmd.description = "generating " + outputs.loggingTest[0].filePath
				loggingTestCmd.highlight = "codegen";
				loggingTestCmd.autogeneratedNotice = autogeneratedNotice
				loggingTestCmd.loggingCategoryId = extensionProduct.name
				loggingTestCmd.namespaceArr = namespaceArr
				loggingTestCmd.namespace = namespace
				loggingTestCmd.includeDirPrefix = FileInfo.relativePath(extensionProduct.sourceDirectory + "/include", outputs.includeDir[0].filePath)
				loggingTestCmd.sourceCode = function() {
					var f = new TextFile(outputs.loggingTest[0].filePath, TextFile.WriteOnly);
					try {
						f.writeLine("#include <" + includeDirPrefix + "/logging.hpp>")

						f.writeLine("")
						f.writeLine("#include <QtTest/QtTest>")

						f.writeLine("")
						f.writeLine("// " + autogeneratedNotice)

						f.writeLine("")
						for (var level in namespaceArr)
							f.writeLine("namespace " + namespaceArr[level] + " {")

						f.writeLine("")
						f.writeLine("class test_logging:")
						f.writeLine("	public QObject")
						f.writeLine("{")
						f.writeLine("	Q_OBJECT")
						f.writeLine("")
						f.writeLine("	private slots:")
						f.writeLine("		void loggingCategory();")
						f.writeLine("};")

						f.writeLine("")
						f.writeLine("void test_logging::loggingCategory()")
						f.writeLine("{")
						f.writeLine("	QCOMPARE(" + namespace + "::loggingCategory().categoryName(), \"" + loggingCategoryId + "\");")
						f.writeLine("}")

						f.writeLine("")
						for (var level in namespaceArr)
							f.writeLine("}")

						f.writeLine("")
						f.writeLine("QTEST_MAIN(" + namespace + "::test_logging)")
						f.writeLine("#include \"test_logging.moc\"")
					} finally {
						f.close()
					}
				}

				var testsQbsCmd = new JavaScriptCommand();
				testsQbsCmd.description = "generating " + outputs.testsQbs[0].filePath
				testsQbsCmd.highlight = "codegen";
				testsQbsCmd.autogeneratedNotice = autogeneratedNotice
				testsQbsCmd.sourceCode = function() {
					var f = new TextFile(outputs.testsQbs[0].filePath, TextFile.WriteOnly);
					try {

						f.writeLine("import qbs")

						f.writeLine("")
						f.writeLine("import \"Test.qbs\" as Test")

						f.writeLine("")
						f.writeLine("// " + autogeneratedNotice)

						f.writeLine("")
						f.writeLine("Project {")
						f.writeLine("	Test {")
						f.writeLine("		testName: \"test_logging\"")
						f.writeLine("")
						f.writeLine("		files: [")
						f.writeLine("			\"test_logging.cpp\"")
						f.writeLine("		]")
						f.writeLine("	}")
						f.writeLine("}")
					} finally {
						f.close()
					}
				}

				var testQbsCmd = new JavaScriptCommand();
				testQbsCmd.description = "generating " + outputs.testQbs[0].filePath
				testQbsCmd.highlight = "codegen";
				testQbsCmd.autogeneratedNotice = autogeneratedNotice
				testQbsCmd.extensionName = product.extension
				testQbsCmd.sourceCode = function() {
					var f = new TextFile(outputs.testQbs[0].filePath, TextFile.WriteOnly);
					try {

						f.writeLine("import qbs")

						f.writeLine("")
						f.writeLine("import cutehmi")

						f.writeLine("")
						f.writeLine("// " + autogeneratedNotice)

						f.writeLine("")
						f.writeLine("cutehmi.Test {")
						f.writeLine("	testNamePrefix: parent.parent.name")
						f.writeLine("")
						f.writeLine("	Depends { name: \"" + extensionName + "\" }")
						f.writeLine("}")
					} finally {
						f.close()
					}
				}

				var result = [includeDirCmd, internalIncludeDirCmd, testsDirCmd]
				if (product.generatePlatform)
					result.push(platformHppCmd)
				if (product.generateCommon)
					result.push(commonHppCmd)
				if (product.generateMetadata)
					result.push(metadataHppCmd)
				if (product.generateLogging)
					result.push(loggingHppCmd, loggingCppCmd)
				if (product.generateLoggingTest)
					result.push(loggingTestCmd)
				if (product.generateTestsQbs) {
					if (File.exists(outputs.testQbs[0].filePath))
						console.warn("File '" + outputs.testQbs[0].filePath + "' already exists, please delete the file manually if you want to overwrite it")
					else
						result.push(testQbsCmd)
					if (File.exists(outputs.testsQbs[0].filePath))
						console.warn("File '" + outputs.testsQbs[0].filePath + "' already exists, please delete the file manually if you want to overwrite it")
					else
						result.push(testsQbsCmd)
				}
				return result
			}

			outputArtifacts: {
				var extensionProduct
				for (i in product.dependencies)
					if (product.dependencies[i].name === product.extension)
						extensionProduct = product.dependencies[i]

				var subdir = extensionProduct.baseName.toLowerCase().replace(/\./g, '/')
				var srcDirPath = extensionProduct.sourceDirectory + "/src/" + subdir
				var includeDirPath = extensionProduct.sourceDirectory + "/include/" + subdir
				var internalIncludeDirPath = includeDirPath + "/internal"
				var testsDirPath = extensionProduct.sourceDirectory + "/tests"
				var platformHppPath = internalIncludeDirPath  + "/platform.hpp"
				var commonHppPath = internalIncludeDirPath  + "/common.hpp"
				var metadataHppPath = includeDirPath  + "/metadata.hpp"
				var loggingHppPath = includeDirPath  + "/logging.hpp"
				var loggingCppPath = srcDirPath  + "/logging.cpp"
				var loggingTestPath = testsDirPath  + "/test_logging.cpp"
				var testsQbsPath = testsDirPath  + "/tests.qbs"
				var testQbsPath = testsDirPath  + "/Test.qbs"

				return [
							{fileTags: ["srcDir", "skeleton"], filePath: srcDirPath},
							{fileTags: ["includeDir", "skeleton"], filePath: includeDirPath},
							{fileTags: ["internalIncludeDir", "skeleton"], filePath: internalIncludeDirPath},
							{fileTags: ["testsDir", "skeleton"], filePath: testsDirPath},
							{fileTags: ["platformHpp", "skeleton"], filePath: platformHppPath},
							{fileTags: ["commonHpp", "skeleton"], filePath: commonHppPath},
							{fileTags: ["metadataHpp", "skeleton"], filePath: metadataHppPath},
							{fileTags: ["loggingHpp", "skeleton"], filePath: loggingHppPath},
							{fileTags: ["loggingCpp", "skeleton"], filePath: loggingCppPath},
							{fileTags: ["loggingTest", "skeleton"], filePath: loggingTestPath},
							{fileTags: ["testsQbs", "skeleton"], filePath: testsQbsPath},
							{fileTags: ["testQbs", "skeleton"], filePath: testQbsPath}
						]
			}

			outputFileTags: ["skeleton"]
		}
	}
}
